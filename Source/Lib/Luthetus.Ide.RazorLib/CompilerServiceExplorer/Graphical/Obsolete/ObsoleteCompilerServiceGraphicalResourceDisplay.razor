@using Luthetus.Common.RazorLib.Dimensions;
@using Luthetus.CompilerServices.Lang.DotNetSolution.CompilerServiceCase;

@{
    var localCompilerServiceResource = CompilerServiceResource;

    var circleRadiusInPixelsCssValue = CompilerServiceDisplayDimensions.CircleRadiusInPixels.ToCssValue();

    var xCenterInPixels = GetXCenterInPixels();
    var xCenterInPixelsCssValue = xCenterInPixels.ToCssValue();

    var yCenterInPixels = GetYCenterInPixels();
    var yCenterInPixelsCssValue = yCenterInPixels.ToCssValue();

    var svgFontSizeInPixelsCssValue = CompilerServiceDisplayDimensions.SvgFontSizeInPixels.ToCssValue();

    var fontSizeStyleAttribute = $"font-size: {svgFontSizeInPixelsCssValue}px;";
}

<g class="luth_ide_compiler-service-resource">
    <circle fill="@GetFill(localCompilerServiceResource)"
            cx="@xCenterInPixelsCssValue" cy="@yCenterInPixelsCssValue" r="@circleRadiusInPixelsCssValue" />

    @{
        var absoluteFilePath = new AbsolutePath(
        localCompilerServiceResource.ResourceUri.Value,
        false,
        EnvironmentProvider);
    }

    @* 
    Render the 'text' twice.

    The first render with 'filter="url(#solid)"'
        will render out the text with a solid color background to it.

    The second render re-writes out the text because otherwise,
        the 'filter' logic results in blurry text.

    https://stackoverflow.com/questions/15500894/background-color-of-text-in-svg
    *@
    <text filter="url(#solid)"
          text-anchor="middle" dominant-baseline="middle"
          x="@xCenterInPixelsCssValue" y="@yCenterInPixelsCssValue"
          style="@fontSizeStyleAttribute"
          fill="var(--luth_primary-foreground-color)">

        @absoluteFilePath.NameWithExtension
    </text>
    <text text-anchor="middle" dominant-baseline="middle"
          x="@xCenterInPixelsCssValue" y="@yCenterInPixelsCssValue"
          style="@fontSizeStyleAttribute"
          fill="var(--luth_primary-foreground-color)">

        @absoluteFilePath.NameWithExtension
    </text>

    @if (ShouldDrawLineConnectingSelfToParent)
    {
        var toTheRightOfParent = 
            xCenterInPixels - ParentXCenterInPixels
            > 0;

        @*
            I'm not sure where I'm going with this logic.
            I want to draw a triangle and calculate the x and y
            offset in regards to the angle created by connecting
            the child and parent.

            This way I can draw the line from the circles' edges,
            instead of their center.
        *@
        var changeParentXPositionBy = toTheRightOfParent
                        ? 5
                        : -5;
                        
        var changeParentYPositionBy = toTheRightOfParent
                        ? 5
                        : 5;

        var changeMyXPositionBy = toTheRightOfParent
                        ? -5
                        : 5;
                        
        var changeMyYPositionBy = toTheRightOfParent
                        ? -5
                        : -5;

        @* Direct connection *@
        <line x1="@((ParentXCenterInPixels + changeParentXPositionBy).ToCssValue())"
              y1="@((ParentYCenterInPixels + changeParentYPositionBy).ToCssValue())"
              x2="@((xCenterInPixels + changeMyXPositionBy).ToCssValue())"
              y2="@((yCenterInPixels + changeMyYPositionBy).ToCssValue())"
              stroke="orange"/>

        @* Triangle base connection *@
        @*<line x1="@ParentXCenterInPixels.ToCssValue()"
              y1="@yCenterInPixelsCssValue"
              x2="@xCenterInPixelsCssValue"
              y2="@yCenterInPixelsCssValue"
              stroke="darkgray">

            <title>
                x1="@ParentXCenterInPixels.ToCssValue()"
                y1="@yCenterInPixelsCssValue"
                x2="@xCenterInPixelsCssValue"
                y2="@yCenterInPixelsCssValue"
            </title>
        </line>*@

        @* Triangle vertical connection *@
        @*<line x1="@ParentXCenterInPixels.ToCssValue()"
              y1="@ParentYCenterInPixels.ToCssValue()"
              x2="@ParentXCenterInPixels.ToCssValue()"
              y2="@yCenterInPixelsCssValue"
              stroke="darkgray">

            <title>
                x1="@ParentXCenterInPixels.ToCssValue()"
                y1="@ParentYCenterInPixels.ToCssValue()"
                x2="@ParentXCenterInPixels.ToCssValue()"
                y2="@yCenterInPixelsCssValue"
            </title>
        </line>*@

        @* TODO: I should look over some Math subjects cause I have no idea
what I'm doing here. I swear it would be something 'relatively'-simple.
Like, given the connection between the two circles, find where the connection
intersects with each circle's outer edge. Somehow use sine to get a y value,
somehow get cosine to get a x value idk profit???

Anyway until then, I'm just drawing a scuffed looking connection that overhangs into
both circles a bit instead of ending at their edges.
        *@
    }
</g>

@if (localCompilerServiceResource is DotNetSolutionResource dotNetSolutionResource &&
     dotNetSolutionResource.DotNetSolutionModel is not null)
{
    var dotNetProjects = dotNetSolutionResource.DotNetSolutionModel.DotNetProjects;

    for (var temporaryIndex = 0; temporaryIndex < dotNetProjects.Count(); temporaryIndex++)
    {
        var index = temporaryIndex;
        var dotNetProject = dotNetProjects[index];

        var cSharpProjectResource = CSharpProjectCompilerService.CompilerServiceResources
            .SingleOrDefault(csr => 
                csr.ResourceUri.Value == dotNetProject.AbsolutePath.FormattedInput);

        if (cSharpProjectResource is not null)
        {
            <CompilerServiceResourceDisplay CompilerServiceResource="cSharpProjectResource"
                                            IndexAmongSiblings="index"
                                            Depth="Depth + 1"
                                            CountOfSiblingsAndSelf="@dotNetProjects.Count()"
                                            ParentXCenterInPixels="xCenterInPixels"
                                            ParentYCenterInPixels="yCenterInPixels"
                                            ShouldDrawLineConnectingSelfToParent="true"/>
        }
    }
}